@startuml StringExtensions.GetAllTags
title StringExtensions.GetAllTags
start
#LightBlue:int startTagIndex
int endTagIndex
var result = new List<T>()
var tagHeader = new TagInfo.TagHeader(text);
repeat
    :startTagIndex = text.IndexOf(startTag, parseIndex, StringComparison.CurrentCultureIgnoreCase);
    #LightBlue:var startTagEndIndex = startTagIndex > -1 ? startTagIndex + startTag.Length : parseIndex;
    :endTagIndex = startTagEndIndex >= 0 ? text.IndexOf(endTag, startTagEndIndex, StringComparison.CurrentCultureIgnoreCase) : -1;
    if (startTagIndex > -1 && endTagIndex > startTagIndex) then (<color:green>yes)
        #LightBlue:int idx = startTagEndIndex;
        #LightBlue:int endTagSearchPosAt = startTagEndIndex;
        #LightBlue:var blockCounter = new int[excludeBlocks.Length];
        while (idx < endTagIndex) is (<color:green>yes)
            #LightBlue:int j = 0;
            while (j < blockCounter.Length) is (<color:green>yes)
                if (text[idx] == excludeBlocks[j]) then (<color:green>yes)
                    :endTagSearchPosAt = idx;
                    :blockCounter[j] += j % 2 == 0 ? 1 : -1;
                endif
            :j++;
            endwhile (<color:red>no)
            :idx++;
        endwhile (<color:red>no)
        while (idx < text.Length && blockCounter.Sum() != 0) is (<color:green>yes)
            #LightBlue:int j = 0;
            while (j < blockCounter.Length) is (<color:green>yes)
                if (text[idx] == excludeBlocks[j]) then (<color:green>yes)
                    :endTagSearchPosAt = idx;
                    :blockCounter[j] += j % 2 == 0 ? 1 : -1;
                endif
            :j++;
            endwhile (<color:red>no)
            :idx++;
        endwhile (<color:red>no)
        if (endTagSearchPosAt > endTagIndex && blockCounter.Sum() == 0) then (<color:green>yes)
            :endTagIndex = text.IndexOf(endTag, endTagSearchPosAt, StringComparison.CurrentCultureIgnoreCase);
        endif
    endif
    if (startTagIndex > -1 && endTagIndex > startTagIndex) then (<color:green>yes)
        :result.Add(new T
                    {
                        Header = tagHeader,
                        StartTag = startTag,
                        StartTagIndex = startTagIndex,
                        EndTag = endTag,
                        EndTagIndex = endTagIndex,
                    });
        :parseIndex = startTagEndIndex;
    endif
repeat while (startTagIndex > -1 && endTagIndex > -1) is (<color:green>yes)
#Lavender:return result;
stop
@enduml
